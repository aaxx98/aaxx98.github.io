{"data":{"allMdx":{"totalCount":9,"nodes":[{"id":"c7329843-3453-5550-9110-b03237d5a605","excerpt":"이번 주에는 Java 프로젝트에 데이터베이스를 연결하고, MyBatis와 JPA를 사용해보는 시간을 가졌습니다. MyBatis로 SQL을 직접 작성하며 데이터베이스와 상호작용하는 방식을 먼저 경험했고, 이후 JPA로 넘어가면서 데이터베이스 연결에…","body":"\n> 이번 주에는 Java 프로젝트에 데이터베이스를 연결하고, MyBatis와 JPA를 사용해보는 시간을 가졌습니다. MyBatis로 SQL을 직접 작성하며 데이터베이스와 상호작용하는 방식을 먼저 경험했고, 이후 JPA로 넘어가면서 데이터베이스 연결에 대한 서로 다른 접근 방식을 배울 수 있었습니다. 실습을 통해 Maven으로 프로젝트 의존성을 관리하면서 라이브러리 추가가 얼마나 간편해졌는지 체감했고, JPA의 영속성 컨텍스트라는 개념을 처음 접하고 이해하는 시간을 가졌습니다.\n\n# Maven으로 JAVA 프로젝트 관리\n\n![Maven](./maven.jpg)\n\n## Maven\n\n- 메이븐(Apache Maven)은 개발자로 하여금 자바 프로젝트 관리를 쉽게 도와주는 빌드 툴입니다.\n  - 기존에는 필요한 라이브러리(jar 파일)를 수동으로 프로젝트에 추가해야 했으며, 협업 시 각 개발 환경의 라이브러리 버전을 일치시키는 작업이 어려워 버전 관리가 복잡했습니다.\n  - Maven은 `pom.xml`에 필요한 라이브러리 정보만 적어주면, Maven이 알아서 중앙 저장소에서 다운로드해서 프로젝트에 추가해줍니다.\n    - **POM**: \"Porject Object Model\"의 약어로 `pom.xml` 파일로 관리되며, 반복적으로 진행되어 왔던 프로젝트 빌드, 리포트, 문서화 작업을 지원합니다.\n\n- 프로젝트를 생성할 때 build system을 설정할 수 있는데, 이 때 maven을 선택 할 수 있습니다.\n  ![Maven 프로젝트 생성](./new-maven.png)\n\n### Maven Central Repository 워크플로\n\n![Maven Central Repository](./maven-workflow.png)\n\n1. 종속성 정의: 개발자가 pom.xml에 필요한 종속성을 지정합니다.\n2. 검색 및 다운로드: Maven은 먼저 로컬 저장소에서 종속성을 검색하고, 없으면 중앙 저장소에서 가져옵니다.\n3. 아티팩트 가져오기: 중앙 저장소에서 가져온 종속성은 로컬 저장소에 저장되어 이후 사용됩니다.\n4. 프로젝트 빌드: Maven은 다운로드된 종속성을 사용하여 프로젝트를 빌드합니다.\n\n예를 들어, MyBatis를 사용하려면 아래와 같이 `pom.xml`을 작성합니다.\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>Mybatis</groupId>\n  <artifactId>MybatisBasic</artifactId>\n  <version>0.0.1-SNAPSHOT</version>\n  <name>MybatisBasic</name>\n  <description>MybatisBasic</description>\n\n  <dependencies>\n\n    <!-- https://mvnrepository.com/artifact/com.mysql/mysql-connector-j -->\n    <dependency>\n      <groupId>com.mysql</groupId>\n      <artifactId>mysql-connector-j</artifactId>\n      <version>9.3.0</version>\n    </dependency>\n\n    <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis -->\n    <dependency>\n      <groupId>org.mybatis</groupId>\n      <artifactId>mybatis</artifactId>\n      <version>3.5.6</version>\n    </dependency>\n\n  </dependencies>\n\n  <build>\n    <plugins>\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.8.1</version>\n        <configuration>\n          <source>17</source>\n          <target>17</target>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n```\n\n1. pom.xml에 **mysql-connector-j**와 mybatis 의존성을 추가합니다.\n2. Maven이 로컬 저장소(~/.m2/repository)에서 해당 라이브러리를 먼저 찾습니다.\n3. 로컬에 없으면 Maven 중앙 저장소에서 다운로드합니다.\n4. 다운로드가 완료되면 External Libraries에 추가되어 프로젝트에서 바로 사용할 수 있습니다.\n   ![External Libraries에](./external-lib.png)\n\n# MyBatis로 데이터베이스에 접근하기\n\nMyBatis는 SQL을 직접 작성하고 Mapper 인터페이스를 통해 호출하는 방식으로, SQL문을 거의 그대로 작성하는 방식입니다.\nMapper 인터페이스를 작성하고, xml에 매핑 정보를 작성하면, MyBatis가 인터페이스 구현체를 생성하여 sql문을 연결시켜줍니다.\n\n## Mapper 인터페이스\n\n```java\npublic interface UserMapper {\n    User selectById(Long id);\n    void insertUser(User user);\n}\n```\n\n## XML 매핑\n\n```xml\n<mapper namespace=\"com.example.UserMapper\">\n    <select id=\"selectById\" parameterType=\"long\" resultType=\"User\">\n        SELECT * FROM users WHERE id = #{id}\n    </select>\n\n    <update id=\"update\" parameterType=\"User\">\n        UPDATE users SET name = #{name} WHERE id = #{id}\n    </update>\n    ...\n</mapper>\n```\n\n# JPA로 데이터베이스에 접근하기\n\n> JPA는 객체 상태 변화를 기반으로 SQL을 자동 생성하고 실행하는 ORM(Object-Relational Mapping) 프레임워크입니다.\n>\n> MyBatis와 달리, SQL을 직접 작성하지 않아도 엔티티 객체의 상태를 변경하면 데이터베이스가 자동으로 업데이트됩니다.\n\n```java\nUser user = entityManager.find(User.class, 1L); // SELECT 쿼리 실행\nuser.setName(\"홍길동\");                          // UPDATE 쿼리 자동 생성\n```\n\n이처럼 JPA에서 user 객체를 변경했을 때, SQL이 자동으로 실행되는 이유는 영속성 컨텍스트(Persistence Context) 때문입니다.\n\nMyBatis에서는 개발자가 SQL을 직접 제어했다면, JPA는 객체의 상태 변화를 추적해서 자동으로 SQL을 생성해준다는 차이가 있었습니다.\n\n## 영속성 컨텍스트(Persistence Context)\n\n- 영속성 컨텍스트는 엔티티 객체를 영구 저장하는 환경으로, 일종의 1차 캐시 역할을 수행합니다.\n- 엔티티를 조회하면 해당 객체가 영속성 컨텍스트에 저장되고, 같은 트랜잭션 내에서 동일 데이터를 다시 조회하면 DB 쿼리를 수행하지 않고 캐시에서 객체를 반환합니다.\n\n```java\nUser user1 = entityManager.find(User.class, 1L); // DB 쿼리 실행\nUser user2 = entityManager.find(User.class, 1L); // 위에서 실행한 쿼리와 같으므로 쿼리를 실행하지 않고 context에서 가져옴\nSystem.out.println(user1 == user2); // true: 같은 객체\n```\n\n## 엔티티의 생명주기\n\n> 엔티티는 영속성 컨텍스트와의 관계에 따라 다음 4가지 상태를 가집니다.\n\n![Entity의 생명주기](./persistence-context.png)\n\n1. **비영속(New/Transient)**: 영속성 컨텍스트와 전혀 관계 없는 새로운 상태\n2. **영속(Managed)**: 영속성 컨텍스트에 관리되는 상태\n3. **준영속(Detached)**: 영속성 컨텍스트에 저장되었다가 분리된 상태\n4. **삭제(Removed)**: 삭제된 상태\n\n```java\n// 비영속\nUser user = new User();\nuser.setName(\"홍길동\");\n\n// 영속\nentityManager.persist(user);\n\n// 준영속\nentityManager.detach(user);\n\n// 삭제\nentityManager.remove(user);\n```\n\n## 더티 체킹(Dirty Checking)\n\n> Dirty라고 하는것은 보통 변경사항을 칭합니다. 변경사항을 추적/감지하는 것을 Dirty Checking이라고 합니다.\n>\n> 영속 상태의 엔티티를 수정하면, JPA가 자동으로 변경 감지를 수행하여 트랜잭션 커밋 시점에 UPDATE 쿼리를 실행합니다.\n\n```java\n@Transactional\npublic void updateUser(Long id, String newName) {\n    User user = entityManager.find(User.class, id);\n    user.setName(newName); // 트랜잭션 커밋 시 자동으로 UPDATE 실행\n}\n```\n\nJPA는 엔티티를 영속성 컨텍스트에 저장할 때 **스냅샷**도 함께 저장합니다.\n\n트랜잭션 커밋 시점에 현재 엔티티와 스냅샷을 비교해서, 변경된 부분이 있으면 UPDATE 쿼리를 자동 생성하는 것입니다.\n\n![더티 체킹 동작 과정](./dirty-checking.png)\n\nMyBatis에서는 UPDATE 쿼리를 직접 작성하고 호출해야 했는데, JPA는 객체만 수정하면 알아서 처리해주니 정말 편리했습니다.\n\n하지만 영속성 컨텍스트에 연결되어있는 객체(영속 상태), 연결되지 않은 객체(비영속/준영속 상태)를 어떻게 구별할지나, 일부 객체만 수정하고싶을 때는 어떻게 관리할 수 있는지 더 알아볼 필요가 있을 것 같습니다.\n\n## 쓰기 지연(Transactional Write-behind)\n\n> persist()를 호출해도 즉시 INSERT 쿼리를 실행하지 않고, 트랜잭션 커밋 시점에 한 번에 실행합니다.\n>\n> 이를 통해 DB와의 통신 횟수를 줄이고 성능을 개선할 수 있습니다.\n\n```java\nUser user1 = new User(\"홍길동\");\nUser user2 = new User(\"김철수\");\nUser user3 = new User(\"이영희\");\n\nentityManager.persist(user1);\nentityManager.persist(user2);\nentityManager.persist(user3);\n\n    // 커밋 시점에 INSERT 쿼리 실행 (홍길동, 김철수, 이영희)\n```\n\n- 필요 시 flush()를 호출하여 중간에 강제로 쿼리를 실행할 수도 있습니다.\n  - 지금까지 영속성 컨텍스트에 쌓여 있는 변경 사항에 대한 쿼리들이 전부 실행됩니다.\n\n## 2차 캐시 - 애플리케이션 전역 캐시\n\n- 영속성 컨텍스트는 1차 캐시로 트랜잭션 단위로 동작합니다.\n- 트랜잭션이 종료되면 캐시도 사라지므로, 다른 트랜잭션에서는 동일 데이터를 조회할 경우 다시 DB에 쿼리가 발생합니다.\n\n```java\n// 트랜잭션 1\nUser user1 = entityManager.find(User.class, 1L); // DB 쿼리\n\n// 트랜잭션 2\nUser user2 = entityManager.find(User.class, 1L); // 또 DB 쿼리\n```\n\n다른 트랜잭션에서는 캐시를 공유하지 않기 때문에, 같은 데이터를 조회해도 매번 DB에 쿼리가 날아갑니다.\n\n애플리케이션 전체에서 공유하는 캐시가 필요하다면 2차 캐시(Second Level Cache)를 사용할 수 있습니다.\n\n다음과 같은 경우 2차 캐시를 사용하는 것이 적합합니다.\n\n- 조회 성능 최적화가 필요한 경우\n- 조회가 빈번하고, 데이터 변경은 드문 경우\n- 여러 트랜잭션에서 동일 데이터를 반복 조회할 때\n\n![캐시](./cache.png)\n\n# 이번 주 TIL 요약\n\n1. **Maven을 통한 프로젝트 관리**\n   - Maven으로 의존성을 관리하면서 라이브러리 추가가 얼마나 간단해졌는지 체감했습니다.\n\n2. **MyBatis와 JPA**\n   - MyBatis를 사용하며 SQL을 직접 작성하고 데이터베이스와 상호작용하는 방식을 먼저 경험했습니다.\n     - 장점: SQL을 직접 제어 가능, 복잡한 쿼리나 성능 튜닝 시 유리\n     - 단점: CRUD마다 SQL을 작성해야 하는 번거로움\n   - 이후 JPA로 전환하면서 객체 중심 개발 방식과 영속성 컨텍스트를 경험했습니다.\n     - 장점: 객체 상태 변경만으로 SQL이 자동 생성되어 생산성이 높음\n     - 단점: 영속성에 대한 이해가 없을 경우, 객체 변경 시 원치 않는 SQL이 실행될 수 있으므로 주의 필요\n\n3. **JPA 영속성 컨텍스트와 더티 체킹**\n   - 영속성 컨텍스트는 엔티티 객체를 관리하는 1차 캐시 역할을 수행하며, 동일 트랜잭션 내에서 DB 접근 없이 객체를 재사용할 수 있음\n   - 더티 체킹을 통해 영속 상태 엔티티를 수정하면, 트랜잭션 커밋 시점에 자동으로 UPDATE 쿼리가 실행됨\n   - MyBatis에서 직접 SQL을 작성하던 것과 달리, 개발자가 비즈니스 로직에 더 집중할 수 있어 편리함\n   - 내부 동작 원리를 이해하면 예기치 못한 쿼리 발생을 예방하고, 안정적으로 활용 가능\n","frontmatter":{"date":"2025년 10월 21일","slug":"til-20251021","title":"JAVA - Maven, Mybatis, JPA","category":"til-challenge","tags":["bootcamp","multi-campus","ureca-backend","database","java"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABOElEQVR42qWTTUvDQBCG+9P1IN6EouJBQaUgCFWLYqGCpSqKChGrgl/YKpU2aWqySTYmGzf7uinpIZc0SeewA8Pw7DtfJWQxISB8NvbTrISMxu7uIYJgRmCsyDu7AK0eIHTdRDwfMAzHLvjowJhfBD2qx3FRVKHsW/RSivDmGv52BVwq40WAk4reNIr9xyGeVQftl2+oxMPhg5YKnTqUWlvFcquLHWUAzWboEz+fwsnfjs+hfBHcdk2sSODxkyaBPgyXJfIyK4zKUnoWzj9tNDsWGq8/OHk30bODnMC4gYIQ/F1eges6WF8FMy3wgQqYRs6hxMBwNIK1sQWyVIY5twC7vApnswIifSEgVzXYa+ugu1V4py24ezW4chd/642CCi1Z4lBP7lG07ELMfnrTzi0bUKSMMgX4D8o/kW0u+lU+AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/5f2dd57d3835641ebe038dbd18c6d76c/27877/java-thumb.png","srcSet":"/static/5f2dd57d3835641ebe038dbd18c6d76c/20f42/java-thumb.png 172w,\n/static/5f2dd57d3835641ebe038dbd18c6d76c/01d54/java-thumb.png 344w,\n/static/5f2dd57d3835641ebe038dbd18c6d76c/27877/java-thumb.png 688w","sizes":"(min-width: 688px) 688px, 100vw"},"sources":[{"srcSet":"/static/5f2dd57d3835641ebe038dbd18c6d76c/6a027/java-thumb.webp 172w,\n/static/5f2dd57d3835641ebe038dbd18c6d76c/f18d0/java-thumb.webp 344w,\n/static/5f2dd57d3835641ebe038dbd18c6d76c/42203/java-thumb.webp 688w","type":"image/webp","sizes":"(min-width: 688px) 688px, 100vw"}]},"width":800,"height":600}}}}},{"id":"d0a60c0e-6e3c-59ba-b14d-7bd8a16ce893","excerpt":"📌 인덱스란? 인덱스는 데이터베이스에서 데이터 검색 속도를 향상시키기 위한 자료구조입니다. 책의 뒷부분에 있는 색인처럼, 특정 데이터를 빠르게 찾을 수 있도록 도와주는 역할을 합니다.\n\n인덱스가 없으면 데이터베이스는 원하는 데이터를 찾기 위해 테이블의…","body":"\n## 📌 인덱스란?\n\n인덱스는 데이터베이스에서 데이터 검색 속도를 향상시키기 위한 자료구조입니다. 책의 뒷부분에 있는 색인처럼, 특정 데이터를 빠르게 찾을 수 있도록 도와주는 역할을 합니다.\n\n인덱스가 없으면 데이터베이스는 원하는 데이터를 찾기 위해 테이블의 모든 행을 처음부터 끝까지 검색(Full Table Scan)해야 하지만 인덱스가 있으면 정렬된 구조를 통해 훨씬 빠르게 데이터를 찾을 수 있습니다.\n\n## 🏗️ 인덱스의 내부 구조\n\n### B-Tree 트리\n\n![B-Tree](./b-tree.png)\n\n대부분의 데이터베이스는 **B-Tree(Balanced Tree)** 구조를 사용합니다.\n\nB-Tree는 균형 잡힌 트리 구조로, 다음과 같은 특징이 있습니다.\n\n> 1. 모든 노드들은 최대 m개의 자식을 가짐\n> 2. 리프 노드를 제외하고, k개의 자식을 가진 노드는 k-1개의 키를 가짐\n> 3. 모든 리프 노드를 제외하고, 최소 m//2 + 1개의 자식을 가져야 함(최소 2개 이상)\n> 4. 모든 리프 노드는 같은 레벨에 있어야 함\n\n- **루트 노드**: 트리의 최상단\n- **브랜치 노드**: 중간 단계 노드들\n- **리프 노드**: 실제 데이터의 위치(포인터)를 가진 최하단 노드\n\n트리 생성 시 최악의 경우 트리가 한쪽으로 치우쳐 O(n) 시간이 걸리는 탐색 구조를 갖게 되는데,\n\nB-Tree는 모든 리프 노드가 동일한 깊이에 있도록 균형을 유지하기 때문에,\n아래와 같이 선형으로 트리가 생성되는 것을 방지합니다.\n![Worse case of Tree algorithm - O(n)](./worse-case-tree.png)\n\n### 인덱스 생성 예시\n\n다음과 같은 users 테이블이 있다고 가정합니다.\n\n![예시 테이블 users](./users-table.png)\n\n인덱스를 생성하면, 원본 테이블과는 별개의 공간에 정렬된 트리 구조로 데이터를 저장합니다. 값으로 정렬되며, 값과 키(id 또는 행 위치)가 저장되어있어 검색에 용이합니다.\n\nusers 테이블에 대해 email 컬럼으로 인덱스를 생성하면 다음과 같은 트리구조가 생성됩니다.\n\n![예시 테이블 users의 email 인덱스 트리](./users-email-index.png)\n\n인덱스 트리를 저장함으로써 데이터 검색 시간이 O(log n)으로 줄어들어, 데이터가 많아져도 검색 속도가 크게 느려지지 않습니다.\n\n하지만 별도의 저장공간이 추가로 필요하며, INSERT, UPDATE, DELETE 작업 시 인덱스 트리를 재정렬 해야하기 때문에 CUD 작업 속도가 느려질 수 있습니다.\n\n읽기가 많은 테이블에서, 자주 조회하는 컬럼만 인덱스를 생성하는 것이 좋습니다.\n\n## 🔍 인덱스 활용\n\n### 1. WHERE 절을 사용한 검색\n\n```\nSELECT * FROM users WHERE email = 'kim@test.com';\n```\n\n다음과 같이 Select 했을 때, `users` 테이블에 대한 인덱스가 없으면 첫번째 행 부터 끝까지 탐색하여 O(n)의 시간이 걸립니다.\n\n하지만 `users.email`에 대한 인덱스가 있는 경우 정렬된 트리에서 값을 찾으므로 검색 시간을 O(log n)으로 줄일 수 있습니다.\n\n### 2. JOIN 연산\n\n```\nSELECT u.name, o.product_name, o.price\nFROM users u\nJOIN orders o ON u.id = o.user_id\nWHERE u.email = 'kim@test.com';\n```\n\nNested Loop Join 방식으로 동작한다고 할 때, 인덱스가 없다면 `users` 테이블의 모든 행 전체 탐색, `orders` 테이블의 모든 행 전체 탐색으로 O(n\\*m)의 시간이 걸립니다.\n\n`users.email`, `orders.user_id`에 인덱스가 있는 경우, 검색 시간을 O(log n + log m)로 줄일 수 있습니다.\n\n### ORDER BY 정렬\n\n이미 정렬되어 저장되어있으므로, 결과 반환만 하면 됩니다. 별도의 정렬을 실행할 필요가 없습니다.\n\n### GROUP BY 그룹화\n\n이미 정렬되어 저장되어있으며, 같은 값에 연속으로 접근할 수 있으므로, 순차적으로 읽으면서 연산 작업을 하면 됩니다.\n\n추가 그룹핑 작업이 필요하지 않습니다.\n\n## 💡 인덱스 사용이 불가능한 경우\n\n인덱스는 특정 컬럼값에 따라 정렬되어 있기 때문에 예상이 불가능한 값으로 조회하려고 할 때는 사용할 수 없습니다.\n\n### ❌ 컬럼에 함수를 사용할 때\n\n```sql\n-- ❌ 함수 연산 결과물은 인덱스로 접근 불가\nSELECT * FROM users WHERE YEAR(created_at) = 2024;\n\n-- ✅\nSELECT * FROM users WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';\n```\n\n### ❌ LIKE 앞에 % 사용할 때\n\n```sql\n-- ❌ 문자열 첫번째 요소를 알 수 없는 경우 인덱스로 접근 불가\nSELECT * FROM users WHERE name LIKE '%김%';\n\n-- ✅\nSELECT * FROM users WHERE name LIKE '김%';\n```\n\n### 카디널리티(Cardinality) 고려\n\n> 카디널리티는 특정 컬럼의 중복되지 않는 값의 개수를 의미합니다.\n>\n> **인덱스는 카디널리티가 높을수록 효과적**입니다.\n\n- **높은 카디널리티**: 이메일, 주민등록번호, 전화번호\n- **낮은 카디널리티**: 성별(남/여), 나이대(10대/20대/30대), 참/거짓\n\n## 📝 인덱스 생성 방법\n\n### 단일 컬럼 인덱스\n\n```sql\n-- 인덱스 생성\nCREATE INDEX idx_email ON users(email);\n\n-- 인덱스 삭제\nDROP INDEX idx_email ON users;\n```\n\n### 복합 인덱스 (여러 컬럼)\n\n```sql\n-- 이름과 나이를 함께 인덱싱, 정렬 우선순위는 왼쪽 컬럼 우선\nCREATE INDEX idx_name_age ON users(name, age);\n```\n\n### 자동 생성되는 인덱스\n\n- **PRIMARY KEY**: 테이블 생성 시 자동으로 인덱스 생성\n- **UNIQUE 제약조건**: 고유값을 보장하기 위해 자동으로 인덱스 생성\n\n```sql\nCREATE TABLE users (\n    id INT PRIMARY KEY,           -- 자동으로 인덱스 생성\n    email VARCHAR(100) UNIQUE     -- 자동으로 인덱스 생성\n);\n```\n\n---\n\n## 🧪 성능 테스트\n\n![mysql](./mysql.png)\n인덱스 검색 성능을 MySQL을 통해 실행해보았습니다.\n\n### 1. 테스트 데이터 준비\n\n```sql\n-- 테스트용 테이블 생성\nCREATE TABLE test_users (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    name VARCHAR(50),\n    email VARCHAR(100),\n    age INT,\n    created_at DATETIME\n);\n\n-- 대용량 데이터 삽입 (100만 건)\nDELIMITER $$\nCREATE PROCEDURE insert_test_data()\nBEGIN\n    DECLARE i INT DEFAULT 1;\n    WHILE i <= 1000000 DO\n        INSERT INTO test_users (name, email, age, created_at)\n        VALUES (\n            CONCAT('User', i),\n            CONCAT('user', i, '@test.com'),\n            FLOOR(20 + RAND() * 50),\n            NOW() - INTERVAL FLOOR(RAND() * 365) DAY\n        );\n        SET i = i + 1;\n    END WHILE;\nEND$$\nDELIMITER ;\n\n-- 프로시저 실행\nCALL insert_test_data();\n```\n\n`test_users` 테이블을 생성하고, 100만건의 데이터가 생성되었습니다. 데이터 생성에 시간이 몇 분 정도 소요됩니다.\n\n![test_users 데이터 count](./create.png)\n\n### 2. 인덱스 없이 검색 테스트\n\n```sql\n-- 실행 계획 확인\nEXPLAIN SELECT * FROM test_users WHERE email = 'user500000@test.com';\n\n-- 실행 시간 측정\nEXPLAIN ANALYZE\nSELECT * FROM test_users WHERE email = 'user500000@test.com';\n```\n\n`EXPLAIN`으로 SELECT문 실행에 대한 정보를 확인하면 아래와 같은 결과가 나옵니다.\n\n- type: ALL - 풀 테이블 스캔 (처음부터 끝까지 탐색)\n- key: NULL - 인덱스를 사용하지 않음\n- rows: 995,849 - 99만 건을 확인해야 할 것으로 추정됨\n- Extra: Using where - WHERE 조건으로 필터링\n\n`EXPLAIN ANALYZE`로 SELECT문 실행 결과를 확인하면 아래와 같은 결과가 나옵니다.\nFilter 작업의 하위에 Table scan이 포함되어있기 때문에 최종 실행 시간은 Filter를 참고하면 됩니다.\n\n```\n-> Filter: (test_users.email = 'user500000@test.com')  (cost=100554 rows=99585) (actual time=215..343 rows=1 loops=1)\n    -> Table scan on test_users  (cost=100554 rows=995849) (actual time=1.27..286 rows=1e+6 loops=1)\n```\n\n- Filter: 각 행을 검사할 때의 조건\n  - cost=100554 rows=99585: MySQL의 쿼리 검사 예측으로, 99585개의 행이 나올것으로 예측함\n  - actual time=215..343: 필터링하는 데 걸린 시간 215~343ms, 전체 실행 시간은 343ms\n  - rows=1: 실제 결과 1건\n  - loops=1: 필터링 1회 수행\n\n- Table scan on test_users: `test_users` 테이블의 전체 행을 처음부터 끝까지 읽는 작업이 발생함\n  - cost=100554 rows=995849: 옵티마이저가 약 99만 행을 읽을 것으로 예측함\n  - actual time=1.27..286: SELECT에 걸린 시간 1.27ms ~ 286ms\n  - rows=1e+6: 실제로 읽은 행 수 - 약 100만 건\n  - loops=1: 테이블 전체를 1회 스캔\n\n### 3. 인덱스 생성 후 테스트\n\n```sql\n-- 인덱스 생성\nCREATE INDEX idx_email ON test_users(email);\n\n-- 실행 계획 확인\nEXPLAIN SELECT * FROM test_users WHERE email = 'user500000@test.com';\n\n-- 실행 시간 측정\nEXPLAIN ANALYZE\nSELECT * FROM test_users WHERE email = 'user500000@test.com';\n```\n\n인덱스를 생성하면 100만건의 데이터가 email 값을 기준으로 B-Tree로 저장됩니다. 인덱스 생성에 3s 정도 소요되었습니다.\n![인덱스 생성](./create-index.png)\n\n`EXPLAIN`으로 SELECT문 실행에 대한 정보를 확인하면 아래와 같은 결과를 확인할 수 있습니다.\n\n- type: ref - 인덱스를 이용해 조건에 맞는 행만 탐색\n- key: idx_email - email 컬럼으로 생성된 인덱스 이름\n- rows: 1 - 1건을 확인해야 할 것으로 추정됨\n- Extra: Using index - 테이블 데이터를 직접 읽지 않고 인덱스만으로 조회 가능\n\n`EXPLAIN ANALYZE`로 SELECT문 실행 결과를 확인하면 아래와 같은 결과가 나옵니다.\n\n```\n-> Index lookup on test_users using idx_email (email='user500000@test.com')  (cost=0.35 rows=1) (actual time=4.38..4.39 rows=1 loops=1)\n```\n\n- Index lookup on test_users: `idx_email` 인덱스를 사용하여 조건에 맞는 행을 바로 찾음\n  - cost=0.35 rows=1: 옵티마이저가 약 1건의 결과를 예측함\n  - actual time=4.38..4.39: 실제 조회에 걸린 시간 — 4.38ms ~ 4.39ms\n  - rows=1: 실제 결과 1건\n\n### 4. 쿼리 실행 시간 비교\n\n> 인덱스 사용으로 실행 시간이 343ms -> 4ms로 86배 빨라졌습니다.\n\n---\n\n## 🎯 요약\n\n다음과 같은 기준으로 인덱스를 고려하면 좋습니다.\n\n- WHERE 절에 자주 사용되는 컬럼\n- JOIN에 사용되는 컬럼\n- ORDER BY에 자주 사용되는 컬럼\n- 카디널리티가 높은 컬럼\n\n### 인덱스 사용 시 장점\n\n- 검색 속도가 대폭 향상\n- ORDER BY, GROUP BY 작업의 성능 개선\n- MIN, MAX 같은 집계 함수가 빨라짐\n\n### 인덱스 사용 시 단점\n\n- 인덱스를 저장하기 위한 추가 디스크 공간이 필요 (테이블 크기의 약 10%)\n- INSERT, UPDATE, DELETE 작업 시 인덱스도 함께 수정해야 하므로 성능이 저하됨\n- 너무 많은 인덱스는 오히려 성능을 떨어뜨릴 수 있으므로 조회 최적화에 사용\n","frontmatter":{"date":"2025년 10월 14일","slug":"til-20251014","title":"데이터베이스 인덱스(Index) 정리 - MySQL 인덱스 실습","category":"til-challenge","tags":["bootcamp","multi-campus","ureca-backend","database","sql"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABuUlEQVR42q2Tyy9DQRTG+6f5I1iKjY3EWmJjYSEhESuJhIVXamMhlEgboR5NhFKl1Vb04dH29nV7X+5r5n7mDqKvoJjkZM59zG++75wZD/55eLr52XGc/wX+BNwV8E4QUZS0L6GeblRtR7MsMggmn2HY5PfADzXpssQjU5Hhjz+8ffsLMF9XEctXeX6QfEKuKvOcNtjnQIsQEOrwhSZptuJQm4erpSorWAndQFRVCJKKwLvKjgopA7rhDptSPhM2t1raSwm4q6g8jzyWeU3bgHPBa8QLNW5pOnDZBDMyPmixBZj5EPTEKkhyHi/sHWpRPNZ1LB5fN1t2H3pnfZjaDWPhKIaeyXUshuK8i+sX9yidjMHK+vCS8EI5nwaxNNS2+qDdLHGAbtmsTA1ASTcxw1QNeQ9Y7GNi5wzDa0GEcwJG1g4hFSLQr2Yg+vshh0ahnI6jHhiAGp6EVWHqlBwrr/0JtAnFs6giURS57bKiYyNyj8HlPb6JJZzDfPCDaEVYpTC06Cx0ZtkqXcJIb8Ku3cIhRntT3A5/HI8Cuw2pkgjZMDueNXx39dw6fkbrYvpmyYXwnLTktGnLV+bWfXILtj+yAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/ebb63e01e087a1bb0cf51c8031eec64b/ce24c/mysql.png","srcSet":"/static/ebb63e01e087a1bb0cf51c8031eec64b/aacf3/mysql.png 200w,\n/static/ebb63e01e087a1bb0cf51c8031eec64b/0e3a3/mysql.png 400w,\n/static/ebb63e01e087a1bb0cf51c8031eec64b/ce24c/mysql.png 800w","sizes":"(min-width: 800px) 800px, 100vw"},"sources":[{"srcSet":"/static/ebb63e01e087a1bb0cf51c8031eec64b/abf68/mysql.webp 200w,\n/static/ebb63e01e087a1bb0cf51c8031eec64b/ce081/mysql.webp 400w,\n/static/ebb63e01e087a1bb0cf51c8031eec64b/c11e0/mysql.webp 800w","type":"image/webp","sizes":"(min-width: 800px) 800px, 100vw"}]},"width":800,"height":600}}}}},{"id":"28de0fd8-75e3-5afd-8009-4f1352b4fa84","excerpt":"MySQL을 사용하면서 자주 찾아보게 되는 명령어들과 핵심 개념들을 정리해봤다. 권한 관리\n데이터베이스 생성 및 조회\n테이블 생성 및 관리\n테이블 구조 변경 (ALTER)\n데이터 삽입 (INSERT)\n데이터 조회 (SELECT)…","body":"\n# TIL 챌린지 주제 선정\n\n> MySQL을 사용하면서 자주 찾아보게 되는 명령어들과 핵심 개념들을 정리해봤다.\n\n![MySQL](./mysql.png)\n\n# 데이터베이스 기본 조작\n\n## 권한 관리\n\n```sql\n-- 사용자 생성\nCREATE USER 'newuser'@'localhost' IDENTIFIED BY 'password';\nCREATE USER 'newuser'@'%' IDENTIFIED BY 'password';  -- 모든 호스트 허용\n\n-- 권한 부여\nGRANT ALL PRIVILEGES ON mydb.* TO 'newuser'@'localhost';\nGRANT SELECT, INSERT, UPDATE ON mydb.users TO 'newuser'@'localhost';\nGRANT SELECT ON mydb.* TO 'readonly'@'localhost';\n\n-- 권한 확인\nSHOW GRANTS FOR 'newuser'@'localhost';\n\n-- 권한 적용\nFLUSH PRIVILEGES;\n\n-- 권한 제거\nREVOKE ALL PRIVILEGES ON mydb.* FROM 'newuser'@'localhost';\n\n-- 사용자 삭제\nDROP USER 'newuser'@'localhost';\n\n-- 비밀번호 변경\nALTER USER 'newuser'@'localhost' IDENTIFIED BY 'newpassword';\n```\n\n## 데이터베이스 생성 및 조회\n\n```sql\n-- 데이터베이스 목록 확인\nSHOW DATABASES;\n\n-- 데이터베이스 생성\nCREATE DATABASE mydb;\nCREATE DATABASE IF NOT EXISTS mydb CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;\n\n-- 데이터베이스 선택\nUSE mydb;\n\n-- 데이터베이스 삭제\nDROP DATABASE mydb;\n```\n\n## 테이블 생성 및 관리\n\n```sql\n-- 테이블 생성\nCREATE TABLE users (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(50) NOT NULL UNIQUE,\n    email VARCHAR(100) NOT NULL,\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    INDEX idx_email (email)\n);\n\n-- 테이블 목록 확인\nSHOW TABLES;\n\n-- 테이블 구조 확인\nDESCRIBE users;\nSHOW CREATE TABLE users;\n\n-- 테이블 삭제\nDROP TABLE users;\nTRUNCATE TABLE users;  -- 데이터만 삭제, 구조는 유지\n```\n\n## 테이블 구조 변경 (ALTER)\n\n```sql\n-- 컬럼 추가\nALTER TABLE users ADD COLUMN age INT;\nALTER TABLE users ADD COLUMN phone VARCHAR(20) AFTER email;\n\n-- 컬럼 수정\nALTER TABLE users MODIFY COLUMN username VARCHAR(100);\nALTER TABLE users CHANGE old_name new_name VARCHAR(50);\n\n-- 컬럼 삭제\nALTER TABLE users DROP COLUMN age;\n\n-- 인덱스 추가/삭제\nALTER TABLE users ADD INDEX idx_username (username);\nALTER TABLE users DROP INDEX idx_username;\n\n-- PRIMARY KEY 추가\nALTER TABLE users ADD PRIMARY KEY (id);\n\n-- FOREIGN KEY 추가\nALTER TABLE orders ADD CONSTRAINT fk_user\n    FOREIGN KEY (user_id) REFERENCES users(id);\n```\n\n---\n\n# CRUD 기본 쿼리\n\n## 데이터 삽입 (INSERT)\n\n```sql\n-- 단일 행 삽입\nINSERT INTO users (username, email) VALUES ('john', 'john@example.com');\n\n-- 여러 행 한번에 삽입\nINSERT INTO users (username, email) VALUES\n    ('jane', 'jane@example.com'),\n    ('bob', 'bob@example.com');\n\n-- 중복 시 무시\nINSERT IGNORE INTO users (username, email) VALUES ('john', 'john@example.com');\n\n-- 중복 시 업데이트\nINSERT INTO users (username, email) VALUES ('john', 'john@example.com')\nON DUPLICATE KEY UPDATE email = VALUES(email);\n```\n\n## 데이터 조회 (SELECT)\n\n```sql\n-- 전체 조회\nSELECT * FROM users;\n\n-- 특정 컬럼만 조회\nSELECT username, email FROM users;\n\n-- 조건부 조회 (WHERE)\nSELECT * FROM users WHERE id = 1;\nSELECT * FROM users WHERE username LIKE 'j%';\nSELECT * FROM users WHERE created_at > '2024-01-01';\n\n-- 정렬 (ORDER BY)\nSELECT * FROM users ORDER BY created_at DESC;\nSELECT * FROM users ORDER BY username ASC, created_at DESC;\n\n-- 상위 n개 컬럼 조회 (LIMIT n)\nSELECT * FROM users LIMIT 10;\n\n-- 중복 제거\nSELECT DISTINCT username FROM users;\n```\n\n## 데이터 수정 (UPDATE)\n\n```sql\nUPDATE users SET email = 'newemail@example.com' WHERE id = 1;\nUPDATE users SET username = 'newname', email = 'new@example.com' WHERE id = 1;\n\nUPDATE users SET email = CONCAT(username, '@newdomain.com')\nWHERE email LIKE '%@olddomain.com';\n```\n\n### 데이터 삭제 (DELETE)\n\n```sql\nDELETE FROM users WHERE id = 1;\nDELETE FROM users WHERE created_at < '2023-01-01';\n```\n\n---\n\n# 조인 (JOIN)\n\n다음과 같이 `users`, `orders` 두 테이블이 있을 때\n![users](./user.png)\n![orders](./order.png)\n\n## INNER JOIN\n\n양쪽 테이블에 모두 존재하는 데이터만 가져온다.\n\n```sql\nSELECT u.username, o.order_id, o.amount\nFROM users u\nINNER JOIN orders o ON u.id = o.user_id;\n```\n\n![inner join](./innerjoin.png)\n\n## LEFT JOIN\n\n왼쪽 테이블의 모든 데이터를 포함하고, 오른쪽 테이블에 매칭되는 데이터가 있으면 가져온다.\n\n```sql\n-- 주문이 없는 사용자도 포함\nSELECT u.username, o.order_id\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id;\n```\n\n![left join](./leftjoin.png)\n\n---\n\n# 집계 함수 (Aggregation)\n\n## 기본 집계 함수\n\n```sql\n-- 개수 세기\nSELECT COUNT(*) FROM users;\nSELECT COUNT(DISTINCT email) FROM users;\n\n-- 합계, 평균, 최대, 최소\nSELECT SUM(amount) FROM orders;\nSELECT AVG(amount) FROM orders;\nSELECT MAX(amount) FROM orders;\nSELECT MIN(amount) FROM orders;\n```\n\n## GROUP BY\n\n```sql\nSELECT user_id, COUNT(*) as order_count, SUM(amount) as total_amount\nFROM orders\nGROUP BY user_id;\n```\n\n## HAVING (그룹화 후 조건)\n\n```sql\nSELECT user_id, COUNT(*) as order_count\nFROM orders\nGROUP BY user_id\nHAVING COUNT(*) > 5;\n```\n\n---\n\n# 그 외\n\n## WITH 절 (CTE)\n\n- WITH 절의 **CTE(Common Table Expression)** 는 임시 결과 집합을 만든다.\n\n### 기본 사용법\n\n```sql\nWITH\nuser_stats AS (\n    SELECT user_id, COUNT(*) as order_count\n    FROM orders\n    GROUP BY user_id\n),\nrevenue_stats AS (\n    SELECT user_id, SUM(amount) as total_revenue\n    FROM orders\n    GROUP BY user_id\n)\n\n-- 테이블처럼 SELECT에 사용할 수 있다.\nSELECT\n    u.username,\n    us.order_count,\n    rs.total_revenue\nFROM users u\nLEFT JOIN user_stats us ON u.id = us.user_id\nLEFT JOIN revenue_stats rs ON u.id = rs.user_id;\n```\n\n## CROSS JOIN\n\n- **CROSS JOIN**은 두 테이블의 모든 가능한 조합 - 카티션 프로덕트를 만든다.\n\n### 기본 사용법\n\n```sql\n-- 모든 색상과 모든 크기의 조합\nSELECT c.color, s.size\nFROM colors c\nCROSS JOIN sizes s;\n\n-- 카티션 프로덕트와 같다.\nSELECT c.color, s.size\nFROM colors c, sizes s;\n```\n\n![colors, sizes 테이블](./colors-sizes.png)\n\n![cross join](./crossjoin.png)\n\n# mysqldump 백업 및 복원\n\n```cmd\n-- 단일 데이터베이스\nmysqldump -u root -p mydb > backup.sql\n\n-- 여러 데이터베이스\nmysqldump -u root -p --databases db1 db2 > backup.sql\n\n-- 모든 데이터베이스\nmysqldump -u root -p --all-databases > backup.sql\n\n-- 특정 테이블만\nmysqldump -u root -p mydb users orders > backup.sql\n\n-- sql 파일 적용\nmysql -u root -p mydb < backup.sql\n```\n","frontmatter":{"date":"2025년 9월 30일","slug":"til-20250930","title":"MySQL 정리","category":"til-challenge","tags":["bootcamp","multi-campus","ureca-backend","database","sql"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABuUlEQVR42q2Tyy9DQRTG+6f5I1iKjY3EWmJjYSEhESuJhIVXamMhlEgboR5NhFKl1Vb04dH29nV7X+5r5n7mDqKvoJjkZM59zG++75wZD/55eLr52XGc/wX+BNwV8E4QUZS0L6GeblRtR7MsMggmn2HY5PfADzXpssQjU5Hhjz+8ffsLMF9XEctXeX6QfEKuKvOcNtjnQIsQEOrwhSZptuJQm4erpSorWAndQFRVCJKKwLvKjgopA7rhDptSPhM2t1raSwm4q6g8jzyWeU3bgHPBa8QLNW5pOnDZBDMyPmixBZj5EPTEKkhyHi/sHWpRPNZ1LB5fN1t2H3pnfZjaDWPhKIaeyXUshuK8i+sX9yidjMHK+vCS8EI5nwaxNNS2+qDdLHGAbtmsTA1ASTcxw1QNeQ9Y7GNi5wzDa0GEcwJG1g4hFSLQr2Yg+vshh0ahnI6jHhiAGp6EVWHqlBwrr/0JtAnFs6giURS57bKiYyNyj8HlPb6JJZzDfPCDaEVYpTC06Cx0ZtkqXcJIb8Ku3cIhRntT3A5/HI8Cuw2pkgjZMDueNXx39dw6fkbrYvpmyYXwnLTktGnLV+bWfXILtj+yAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/ebb63e01e087a1bb0cf51c8031eec64b/ce24c/mysql.png","srcSet":"/static/ebb63e01e087a1bb0cf51c8031eec64b/aacf3/mysql.png 200w,\n/static/ebb63e01e087a1bb0cf51c8031eec64b/0e3a3/mysql.png 400w,\n/static/ebb63e01e087a1bb0cf51c8031eec64b/ce24c/mysql.png 800w","sizes":"(min-width: 800px) 800px, 100vw"},"sources":[{"srcSet":"/static/ebb63e01e087a1bb0cf51c8031eec64b/abf68/mysql.webp 200w,\n/static/ebb63e01e087a1bb0cf51c8031eec64b/ce081/mysql.webp 400w,\n/static/ebb63e01e087a1bb0cf51c8031eec64b/c11e0/mysql.webp 800w","type":"image/webp","sizes":"(min-width: 800px) 800px, 100vw"}]},"width":800,"height":600}}}}},{"id":"8dd27941-3448-5d55-bafa-06d4459b6f45","excerpt":"스터디 팀원으로 참여해 본 적은 많지만 주도적으로 운영해 본 적은 없던 것 같다. 이번에 멀티캠퍼스에서 스터디 이벤트를 열었는데, 대면 스터디가 대부분이었다. 비대면 학습을 진행하다보니 같은 반 수강생들과 교류할 기회가 부족해서 아쉬운 마음에…","body":"\n![스터디1](./001.png)\n\n# TIL 챌린지 주제 선정\n\n![스터디 제안](./message.png)\n\n> 스터디 팀원으로 참여해 본 적은 많지만 주도적으로 운영해 본 적은 없던 것 같다.\n>\n> 이번에 멀티캠퍼스에서 스터디 이벤트를 열었는데, 대면 스터디가 대부분이었다. 비대면 학습을 진행하다보니 같은 반 수강생들과 교류할 기회가 부족해서 아쉬운 마음에 비대면 스터디를 열어보았다.\n>\n> 사실 운영해야 하는 것에 부담을 느끼고 있었는데, 고민 끝에 친분이 좀 생긴 비대면반 모임에 제안을 해보았다. 전부 참여하고 싶다고 해 주셨다! (정말 기뻤습니다🥹)\n>\n> 경기도민으로써 체력을 아낄 수 있도록 비대면으로 잘 진행 해 보려고 한다.\n\n![스터디2](./002.png)\n\n---\n\n# 스터디 운영 기획\n\n## 주제 선정\n\n스터디 주제는 CS(Computer Science) 기본 지식으로 결정했다.\n\n### 스터디 운영 방식\n\n![진행방식](./진행방식.png)\n\n운영 방식에 대해서 고민이 많았는데, 문서를 편집하느라 무의미한 시간을 보내지 않았으면 좋겠다고 생각했다.\n\n그래서 주제를 정하고 중요 키워드 위주로, 부족한 부분만 함께 정리해보는 방식을 제안했다.\n\n- 매주 공통 주제 선정\n- 관련 키워드 조사, 각자 내용 학습: [tech-interview-for-developer](https://github.com/gyoogle/tech-interview-for-developer) 참고\n- 스터디 전날까지 발생한 질문사항 공유\n- 키워드와 질문사항에 대해 스터디 시간에 답변하고, 빠르게 정리\n\n> **질문 확인 및 답변, 정리 -> 다음 주 주제 선정 -> 과제: 키워드 조사 및 학습, 질문 사항 공유**\n\n위와 같은 방식으로 진행하기로 했다.\n\n주제 선정 방식은 매주 다음 주제를 선정하도록 했지만, 틀이 될만한 주제들을 미리 정해두었다.\n\n- 다른 스터디 레포의 목차, CS 도서 목차 등을 참고해서 선정했다.\n  ![스터디 주제](./주제.png)\n\n정리 방식은 두 가지를 제안했는데, Github Repository를 활용하는 것과, 노션의 공동 편집 기능을 사용하는 것이다.\n각각의 장점은 아래와 같다.\n\n**1. GitHub Repository 활용**\n\n- Git/GitHub 사용을 연습할 기회\n- Issue/Pull Request와 같은 기능을 사용해 볼 수 있음\n\n**2. Notion 공동편집**\n\n- 모두에게 익숙한 툴이기 때문에 정리 시간이 적게 소요됨\n- 실시간으로 함께 편집 가능\n\n> 이번 기회에 Git/GitHub를 익히고싶다는 의견이 많아서 Github Repository를 활용하기로 결정했다. 스터디 레파지토리이기 때문에 실수해도 걱정 없다.\n\n## CS 스터디 레파지토리 운영 방식들\n\nGithub에 `CS 스터디`로 검색하여 다른 스터디 레파지토리의 운영 방식을 참고해 보았다.\n\n![cs 스터디 검색 결과](./github.png)\n\n- `README.md`에 스터디 규칙을 작성한다.\n- Issue에 주제를 올리고, Comment로 각자 질문을 달아 둔다.\n- 주제별 디렉토리를 만들고 Markdown 형식으로 정리한다. `[경로]/README.md`에 작성하면 Github 웹 뷰에서 보기 편하다.\n- 같은 주제에서 각자 이름으로 파일을 만들어 내용을 정리하거나, 한 주제를 여러 파트로 나눠서 각자 정리한다.\n\n---\n\n## 기대 효과 및 앞으로의 계획\n\n이번 CS 스터디는 아래와 같은 목표를 가지고 있다.\n\n- 체계적인 CS 지식 습득: 단순 암기가 아닌 이해 중심의 학습\n- 협업 도구 숙련도 향상: Git/GitHub 활용 능력 개발\n- 질문하는 습관 형성: 모르는 것을 부끄러워하지 않고 적극적으로 질문하는 문화 조성\n- 지식 공유와 토론: 각자의 관점에서 바라본 내용을 공유하며 더 깊이 있게 이해\n\n![이번 주 issue 등록](./issue.png)\n\n이번 주 스터디는 목요일에 예정되어 있다. 스터디 Repository에 첫 주 Issue 등록을 완료하고, 키워드 및 질문 작성 가이드를 남겨 두었다.\n\n첫 스터디 시간 전 까지 간략한 스터디 소개와 규칙을 작성하고, 첫 시간에는 `fork`하여 `pull request`하는 법 등에 대해 정리하여 공유하려고 한다.\n\n또, 아직 내용 정리에 대해서는 돌아가며 한 사람이 할 지, 매 주 여러 사람이 할지, 각자 파트를 정리할 지... 갈피를 잡지 못했는데 첫 시간을 진행해 본 뒤 편집 방식을 결정하려고 한다.\n\n나아가서 CS 주제 이외에도, 새로 스터디 하고 싶은 내용이 생긴다면 다른 주제로, 다른 팀원을 모집하여 진행해보고 싶기도 하다.\n","frontmatter":{"date":"2025년 9월 23일","slug":"til-20250923","title":"GitHub Repository를 이용해서 비대면 스터디 운영하기","category":"til-challenge","tags":["bootcamp","multi-campus","ureca-backend","github","study"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAADfElEQVR42lWT+08aWRiG+TP38tMmTbY2KnVVarvVekfdXmzcNk1t2prsaja72datq66XKtRqVBhguAiIFhAQVEAHUGCYefYw1r2cyTvfd3Jmnrzn+84xVbw9bNne4PGHOUvH0KslyMdBOYRMCHLRy/nxLmoxj7I7he7rQN0ZQQ30U/PfE/mgkWu+LkwVuYuTwwAUMvDxFbprGn3hMSyMwvIT9JAdfcYKP5tRnbMosbfo7haqAqjtWNECPdR2BgxpgW5MZbkbJReBoPjRNg6rz8AmtCig75+Ab/YSPmmmtPE7BzszsNsDESu1usPgoIB9VtAqgGLLp4ltqJURCblEhGhAonQUI58IE/VuoiR34SxBWcni+fgr739qxvWHBUICGOgzwKpfRH9PfcvCYcbH1Zibn+fx2BgOpwOb3caDh4/48MFurFVrGkn3FL88vUfDN1+TWusS0D40IfYHRQl6BdDb9x9gjaXFv/j+zm12Al5WVpbo6+vBtrpsrKpqhZRvmpw8w/JkP4rjjgHcX77N4oQFxWOtA+sOvf8AS6UCufwJlcoFxYLCYSrO+XnRWKuJdzYwydrbHzmUJ2BvkIK7F9/Sc54NDbHw+uZll+tATXxcOZCpxd2QlIlH/ITDQVLJGB7HJhdKjkpJIb23ztqGnfsPbqEGh0Rnu0htPmfltwlG7zZ8dpj2Eo3FcG2sEpa3CHs2CQVkXC4Hn0J+ipJTFN1HWeTnF+dIssQXDV8x+qiRsvh/8XUrS1O9DFu+xVR1dwigB108avUCTVfRNFXMaiJW0YXQxWZFjAUl8sdHjE+O03D3Oo3dZqZe9hKa/Y6ce4g/X7YKoKtVXArJqGCpkCd9mCCZiBKL7hl5StQwIeaaOFZnp1nezc3Q1NVES38L5s4brL3pQPNa8M2Yyax31IFthkPjWAiHJVGnYvH/Kojm1Ec09okblusCdhOzcNfQdg3fXDtZxyAR+zDxte5LYHZ/lXQ8QD4ToXSWoiQOeF3F/IGIB2TTYY5iThbevaCpsxnzQAtNA+00d1xjyz5l3DQlG+Q46cSEtx1NFh1zt1Hz3PpX8lVuoepqR5UaKXjvI20vMP7KysOxdro7v8S5PS+8n3Be3KdSPsCUk0bIS8NCl/HUNWLoKj9z/0C+Hl3DJBxPycS3ROfXSUov2Ji+hyxvUMjvk4p7yST9/A1OoffZHxBhuQAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/fe074fa7807b608d1550059151ce1add/ce24c/001.png","srcSet":"/static/fe074fa7807b608d1550059151ce1add/aacf3/001.png 200w,\n/static/fe074fa7807b608d1550059151ce1add/0e3a3/001.png 400w,\n/static/fe074fa7807b608d1550059151ce1add/ce24c/001.png 800w","sizes":"(min-width: 800px) 800px, 100vw"},"sources":[{"srcSet":"/static/fe074fa7807b608d1550059151ce1add/abf68/001.webp 200w,\n/static/fe074fa7807b608d1550059151ce1add/ce081/001.webp 400w,\n/static/fe074fa7807b608d1550059151ce1add/c11e0/001.webp 800w","type":"image/webp","sizes":"(min-width: 800px) 800px, 100vw"}]},"width":800,"height":600}}}}},{"id":"c8455c7c-5e31-5b66-8aaf-d7b7fc656b18","excerpt":"지금까지 웹개발을 하면서, 주로 JavaScript, PHP, Go 같은 언어를 사용해왔다. 이런 언어들은 슬라이스(slice)나 딕셔너리(dictionary)처럼 데이터를 다루기 편리한 문법을 기본으로 제공한다. 반면 Java는 배열을 선언하면…","body":"\n![til 챌린지 Java의 Collections와 Stream](./til-start.png)\n\n# TIL 챌린지 주제 선정\n\n> 지금까지 웹개발을 하면서, 주로 JavaScript, PHP, Go 같은 언어를 사용해왔다.\n> 이런 언어들은 슬라이스(slice)나 딕셔너리(dictionary)처럼 데이터를 다루기 편리한 문법을 기본으로 제공한다.\n>\n> 반면 Java는 배열을 선언하면 고정 길이를 가지기 때문에, 슬라이스나 딕셔너리 처럼 사용하기에는 불편함이 있다.\n> 리스트, 맵, 집합 등 다양한 자료구조를 다루려면 `java.util`의 컬렉션 패키지를 사용하는 것이 보편적인 듯 하다.\n>\n> 이번주 TIL 챌린지에서는 Java에서 데이터를 다루는 기본 도구인 컬렉션(Collection)과, 데이터를 선언적이고 함수형 스타일로 처리할 수 있는 스트림(Stream)에 대해 살펴보았다.\n\n![java](./java-thumb.png)\n\n# Java의 Collections\n\n> Java 플랫폼에는 Collections 프레임워크가 포함되어 있다.\n>\n> 컬렉션은 객체 그룹을 나타내는 객체로, 기본적인 자료구조에 대한 인터페이스와 구현체를 제공한다.\n>\n> primitive 타입의 배열이 아닌 경우, Object의 배열, 집합, 큐 등을 사용하게 된다면 Collections를 사용하게 되므로 알아보자.\n\n## Collections의 인터페이스\n\n![Collections의 인터페이스](./collections-interface.png)\n\n### 1. Collection 인터페이스\n\n`Collection` 인터페이스는 모든 컬렉션의 루트 인터페이스로, 기본적인 컬렉션 연산을 정의한다.\n\n**주요 메서드**\n\n- `add(E e)`: 요소 추가\n- `remove(Object o)`: 요소 제거\n- `contains(Object o)`: 요소 포함 여부 확인\n- `size()`: 컬렉션 크기 반환\n- `isEmpty()`: 빈 컬렉션 여부 확인\n- `iterator()`: Iterator 반환\n\n```java\nCollection<String> collection = new ArrayList<>();\ncollection.add(\"Java\");\ncollection.add(\"Python\");\nSystem.out.println(collection.size()); // 2\nSystem.out.println(collection.contains(\"Java\")); // true\n```\n\n### 2. List 인터페이스\n\n`List`는 순서가 있는 컬렉션으로, 중복 요소를 허용하며 인덱스로 요소에 접근할 수 있다.\n\n**특징**\n\n- 순서 보장 (insertion order)\n- 중복 허용\n- 인덱스 기반 접근\n\n**주요 구현체**\n\n- `ArrayList`: 동적 배열, 빠른 조회\n- `LinkedList`: 이중 연결 리스트, 삽입과 삭제가 빠름\n- `Vector`: 동기화된 ArrayList (legacy 클래스로 사용하지 않는 것을 추천)\n\n```java\nList<Integer> numbers = new ArrayList<>();\nnumbers.add(10);\nnumbers.add(20);\nnumbers.add(10); // 중복 허용\n\n// 인덱스 기반 접근\nSystem.out.println(numbers.get(0)); // 10\nnumbers.set(1, 25); // 인덱스 1의 값을 25로 변경\n\n// 특정 위치에 삽입\nnumbers.add(1, 15); // {10, 15, 25, 10}\n```\n\n### 3. Set 인터페이스\n\n`Set`은 중복 요소를 허용하지 않는 컬렉션이다.\n\n**특징:**\n\n- 중복 불허\n- 수학적 집합의 개념\n\n**주요 구현체**\n\n- `HashSet`: 해시 테이블 기반, O(1) 성능\n- `LinkedHashSet`: 삽입 순서를 보장하는 HashSet\n- `TreeSet`: 정렬된 집합, Red-Black Tree 구조\n\n```java\nSet<String> languages = new HashSet<>();\nlanguages.add(\"Java\");\nlanguages.add(\"Python\");\nlanguages.add(\"Java\"); // {\"Java\", \"Python\"}\n\nSystem.out.println(languages.size()); // 2\n\n// TreeSet 사용 시 자동 정렬\nSet<Integer> sortedNumbers = new TreeSet<>();\nsortedNumbers.add(30);\nsortedNumbers.add(10);\nsortedNumbers.add(20);\nSystem.out.println(sortedNumbers); // [10, 20, 30]\n```\n\n### 4. Queue 인터페이스\n\n`Queue`는 FIFO(First-In-First-Out) 방식으로 요소를 처리하는 컬렉션이다.\n\n**주요 메서드**\n\n- `offer(E e)`: 큐에 요소 추가\n- `poll()`: 큐에서 요소 제거하고 반환\n- `peek()`: 큐의 첫 번째 요소 조회 (제거하지 않음)\n\n**주요 구현체**\n\n- `LinkedList`: Queue 인터페이스도 구현\n- `PriorityQueue`: 우선순위 큐\n- `ArrayDeque`: 양방향 큐\n\n```java\nQueue<String> queue = new LinkedList<>();\nqueue.offer(\"First\");\nqueue.offer(\"Second\");\nqueue.offer(\"Third\");\n\nSystem.out.println(queue.poll()); // \"First\"\nSystem.out.println(queue.peek()); // \"Second\" (제거되지 않음)\n```\n\n### 5. Deque 인터페이스\n\n`Deque`(Double-ended Queue)는 양쪽 끝에서 삽입과 삭제가 가능한 큐이다.\n\n**특징**\n\n- 양방향 큐 (Double-ended Queue)\n- 스택과 큐의 기능을 모두 제공\n- LIFO와 FIFO 모두 지원\n\n**주요 구현체**\n\n- `ArrayDeque`: 동적 배열 기반, 성능이 뛰어남\n- `LinkedList`: 이중 연결 리스트, 메모리 오버헤드 존재\n- `ConcurrentLinkedDeque`: 동시성 지원하는 링크 기반 덱\n\n```java\nDeque<Integer> deque = new ArrayDeque<>();\n\n// 양쪽 끝에 요소 추가\ndeque.addFirst(1);\ndeque.addLast(2);\ndeque.addFirst(0); // [0, 1, 2]\n\n// 스택처럼 사용\ndeque.push(3); // [3, 0, 1, 2]\nSystem.out.println(deque.pop()); // 3, [0, 1, 2]\n\n// 큐처럼 사용\ndeque.offer(4); // [0, 1, 2, 4]\nSystem.out.println(deque.poll()); // 0, [1, 2, 4]\n\n// 양쪽 끝 요소 조회\nSystem.out.println(deque.peekFirst()); // 1\nSystem.out.println(deque.peekLast()); // 4\n\n// 양쪽 끝에서 제거\nSystem.out.println(deque.removeFirst()); // 1\nSystem.out.println(deque.removeLast()); // 4\n```\n\n### 6. Map 인터페이스\n\n`Map`은 키-값 쌍으로 데이터를 저장하는 인터페이스로, Collection을 상속하지 않지만 컬렉션 프레임워크의 일부이다.\n\n**특징:**\n\n- 키-값 매핑\n- 키는 중복 불허, 값은 중복 허용\n\n**주요 구현체**\n\n- `HashMap`: 해시 테이블 기반\n- `LinkedHashMap`: 삽입 순서 보장\n- `TreeMap`: 키로 정렬된 맵\n\n```java\nMap<String, Integer> scores = new HashMap<>();\nscores.put(\"Alice\", 95);\nscores.put(\"Bob\", 87);\nscores.put(\"Charlie\", 92);\n\nSystem.out.println(scores.get(\"Alice\")); // 95\nSystem.out.println(scores.containsKey(\"Bob\")); // true\n\n// 모든 키-값 쌍 순회\nfor (Map.Entry<String, Integer> entry : scores.entrySet()) {\n    System.out.println(entry.getKey() + \": \" + entry.getValue());\n}\n```\n\n## Collections 클래스 계층 구조 한눈에 보기\n\n![Collections 클래스 계층 구조 한눈에 보기](./collections.png)\n\n---\n\n# Stream\n\n> Stream API는 Java 8에서 도입된 함수형 프로그래밍 패러다임을 지원하는 기능으로, 컬렉션 데이터를 선언적 방식으로 처리할 수 있게 해준다.\n>\n> 스트림을 사용하면 컬렉션이나 배열을 반복문(`for`, `while`) 없이 처리 할 수 있는데,\n> JavaScript에서 자주 사용하는 라이브러리인 lodash나 Rxjs와 비슷한 패러다임으로 느꼈다.\n\n![Stream](./stream.jpg)\n\n- 위와 같이 Stream은 컬렉션이나 배열 등의 여러 데이터 묶음을 처리한다. 순회, 필터링, 집계와 같은 처리에 사용하며, 병렬 처리를 지원하기도 한다.\n\n## Stream의 특징\n\n### 선언적(Declarative)\n\n- 직접 반복문이나 조건문을 쓰지 않고, 람다나 메서드를 전달하여 처리 - 함수형 프로그래밍\n\n```java\nList<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\nnames.stream()\n     .filter(n -> n.length() <= 4)  // 필터 조건 정의\n     .map(String::toUpperCase)      // 변환 방식 정의\n     .forEach(System.out::println);\n\n```\n\n### 파이프라이닝(Pipelining)\n\n- 여러 중간 연산을 연결하여 하나의 연속적인 처리 과정을 구성\n- Stream 연산을 마치 파이프처럼 이어 붙여 복합 연산을 간결하게 작성\n\n```java\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);\nint sum = numbers.stream()\n                 .filter(n -> n % 2 == 0)   // 짝수만 필터\n                 .map(n -> n * n)           // 제곱으로 변환\n                 .reduce(0, Integer::sum);  // 합계 계산\nSystem.out.println(sum); // 20\n```\n\n- filter → map → reduce가 연속적으로 연결되어 하나의 처리 흐름이 됨\n\n### 내부 반복(Internal Iteration)\n\n- Stream이 요소를 반복 처리하는 로직을 내부에서 수행하여 반복문을 작성할 필요가 없음\n- 기존 컬렉션 반복(Iterator, for-each)은 외부 반복(External Iteration)\n- 내부의 모든 요소에 대해 전달한 동작을 실행한다고 생각하자.\n\n![스트림의 내부 반복](./internal-iteration.png)\n\n```java\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\");\nlist.stream().forEach(System.out::println); // 내부 반복, 전체 요소 출력\n```\n\n```bash\n출력 결과\n---\na\nb\nc\n```\n\n### 지연 실행(Lazy Evaluation)\n\n- 중간 연산은 바로 실행되지 않고, 최종 연산이 호출될 때 실행됨\n- 불필요한 연산을 줄여 성능 최적화 가능\n\n```java\nList<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\nStream<String> stream = names.stream()\n                             .filter(n -> {\n                                 System.out.println(\"filter 호출: \" + n);\n                                 return n.length() <= 4;\n                             });\nSystem.out.println(\"아직 filter 실행 안됨\");\n\nList<String> result = stream.collect(Collectors.toList()); // 여기서 filter가 실제로 실행된다.\n```\n\n## Stream의 사용 방법\n\n![](./stream-step.png)\n\n- Stream의 사용 방식은 스트림 생성, 중간 연산, 최종 연산 세 단계로 분류 할 수 있다.\n\n### 1. 스트림 생성\n\n- 연산 파이프라인을 붙일 스트림을 생성해야한다. 스트림 생성에 사용된 컬렉션 객체 또는 배열은 스트림 연산이 실행되어도 변경되지 않는다.\n- 컬렉션, 배열로부터 생성할 수 있고, 원본이 없는 경우 of로 스트림을 생성할 수 있다.\n- 무한스트림은 끝이 없는 Stream으로, 요소를 계속 생성할 수 있으며 주로 계산, 난수 생성, 시퀀스 생성 등에서 사용한다.\n\n```java\n// 컬렉션에서 생성\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\");\nStream<String> stream1 = list.stream();\n\n// 배열에서 생성\nString[] array = {\"x\", \"y\", \"z\"};\nStream<String> stream2 = Arrays.stream(array);\n\n// 직접 생성\nStream<String> stream3 = Stream.of(\"hello\", \"world\");\n\n// 무한 스트림 생성\nStream<Integer> infiniteStream = Stream.iterate(0, n -> n + 1);\nStream<Double> randomStream = Stream.generate(Math::random);\n```\n\n### 2. 중간 연산\n\n- 중간 연산은 Stream을 반환하므로, 계속해서 여러 연산을 연결해서 파이프라인을 만들 수 있다.\n- 중간 연산은 **지연 실행(lazy)**되므로 최종 연산이 호출될 때까지 실제로 실행되지 않는다.\n- 중간 연산의 종류 몇 가지\n  - `filter`: 필터링, 조건에 맞는 요소만 남김\n  - `map`: 매핑, 요소를 다른 값으로 변환\n  - `sorted`: 정렬\n  - `distinct`: 중복 제거\n  - `limit`: 최대 n개 요소만 남김\n  - `skip`: 처음 n개 요소 제외\n\n```java\nList<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\nStream<String> stream = names.stream()\n                             .filter(n -> n.length() <= 4)  // 4글자 이하인 것만 필터링\n                             .map(String::toUpperCase);     // 대문자로 변환\n\nStream<Integer> sortedStream = Stream.of(3,1,4,2).sorted(); // 1,2,3,4\nStream<Integer> distinctStream = Stream.of(1,2,2,3,1).distinct(); // 1,2,3\n\nStream<Integer> limited = Stream.iterate(1, n -> n + 1).limit(5); // 1,2,3,4,5\nStream<Integer> skipped = Stream.iterate(1, n -> n + 1).skip(3).limit(3); // 4,5,6\n```\n\n### 3. 최종 연산\n\n- 최종 연산이 실행 될 때, 모든 중간 연산이 실행된다.\n- 결과를 반환한다.\n- 최종 연산의 종류 몇 가지\n  - `collect`: 스트림의 결과를 컬렉션, 맵, 문자열 등으로 모아서 변환\n  - `forEach`: 스트림의 각 요소를 순회하며 주어진 동작 실행\n  - `reduce`: 스트림의 요소를 하나의 값으로 누적\n  - `count`: 스트림 요소의 개수 반환\n\n```java\nList<String> result = stream.collect(Collectors.toList()); // stream 연산 결과를 result 리스트에 할당\n\nStream.of(1,2,3).forEach(System.out::println); // 1 2 3 출력\n\nint sum = Stream.of(1,2,3,4).reduce(0, Integer::sum); // 10\nOptional<Integer> max = Stream.of(1,2,3,4).reduce(Integer::max); // 4\n\nlong evenCount = Stream.of(1,2,3,4,5)\n                       .filter(n -> n % 2 == 0)\n                       .count(); // 2\n```\n\n---\n\n# 참고\n\n## 공식 문서\n\n- [Oracle Java Collections Tutorial](https://docs.oracle.com/javase/tutorial/collections/index.html)\n- [Stream API Documentation](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)\n- [Processing Data with Java SE 8 Streams - Oracle](https://www.oracle.com/technical-resources/articles/java/ma14-java-se-8-streams.html)\n- [Java SE Stream API - Dev.java](https://dev.java/learn/api/streams/)\n","frontmatter":{"date":"2025년 9월 16일","slug":"til-20250916","title":"Java의 Collections와 Stream","category":"til-challenge","tags":["bootcamp","multi-campus","ureca-backend","java"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABOElEQVR42qWTTUvDQBCG+9P1IN6EouJBQaUgCFWLYqGCpSqKChGrgl/YKpU2aWqySTYmGzf7uinpIZc0SeewA8Pw7DtfJWQxISB8NvbTrISMxu7uIYJgRmCsyDu7AK0eIHTdRDwfMAzHLvjowJhfBD2qx3FRVKHsW/RSivDmGv52BVwq40WAk4reNIr9xyGeVQftl2+oxMPhg5YKnTqUWlvFcquLHWUAzWboEz+fwsnfjs+hfBHcdk2sSODxkyaBPgyXJfIyK4zKUnoWzj9tNDsWGq8/OHk30bODnMC4gYIQ/F1eges6WF8FMy3wgQqYRs6hxMBwNIK1sQWyVIY5twC7vApnswIifSEgVzXYa+ugu1V4py24ezW4chd/642CCi1Z4lBP7lG07ELMfnrTzi0bUKSMMgX4D8o/kW0u+lU+AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/5f2dd57d3835641ebe038dbd18c6d76c/27877/java-thumb.png","srcSet":"/static/5f2dd57d3835641ebe038dbd18c6d76c/20f42/java-thumb.png 172w,\n/static/5f2dd57d3835641ebe038dbd18c6d76c/01d54/java-thumb.png 344w,\n/static/5f2dd57d3835641ebe038dbd18c6d76c/27877/java-thumb.png 688w","sizes":"(min-width: 688px) 688px, 100vw"},"sources":[{"srcSet":"/static/5f2dd57d3835641ebe038dbd18c6d76c/6a027/java-thumb.webp 172w,\n/static/5f2dd57d3835641ebe038dbd18c6d76c/f18d0/java-thumb.webp 344w,\n/static/5f2dd57d3835641ebe038dbd18c6d76c/42203/java-thumb.webp 688w","type":"image/webp","sizes":"(min-width: 688px) 688px, 100vw"}]},"width":800,"height":600}}}}},{"id":"8aae0dc5-e03d-5b34-ad5f-4983782d046c","excerpt":"첫번째 TIL 글로 IntelliJ에서 패키지/클래스 생성법과, JAR 파일 만들고 실행하는 방법을 정리해보려고 한다. Java IDE로 Eclipse도 많이 쓰지만, IntelliJ를 설치하여 사용중이었기 때문에 수업에서 사용하지 않아도 그대로…","body":"\n# TIL 챌린지를 시작하며\n\n첫번째 TIL 글로 IntelliJ에서 패키지/클래스 생성법과, JAR 파일 만들고 실행하는 방법을 정리해보려고 한다.\n\n> Java IDE로 **Eclipse**도 많이 쓰지만, **IntelliJ**를 설치하여 사용중이었기 때문에 수업에서 사용하지 않아도 그대로 사용하고있다.\n> 수업 시간에 JAR 만들기를 Eclipse로 진행하고 있어서 급히 다른 블로그 글을 보고 처리했는데,\n> 다른 IntelliJ를 사용하는 분들이 질문하셨던 것에 링크만 공유하고 자세히 답을 못 드렸어서 이번 TIL에 남겨보았다.\n\n---\n\n## IntelliJ Community 소개\n\n![IntelliJ](./til-20250909.png)\n\n**IntelliJ Community**는 무료 버전이지만, Java/Kotlin/Groovy, Maven/Gradle, JUnit 등 순수 자바 개발에 필요한 기능은 충분히 사용할 수 있다.\n\n다만 **Spring/Java EE, Web 프레임워크, 공식 Database Tools**는 **IntelliJ Ultimate**에서 사용할 수 있다.\n\n---\n\n### 설치 방법 (macOS 기준)\n\n1. **[IntelliJ IDEA Community 다운로드 (JetBrains)](https://www.jetbrains.com/ko-kr/idea/download)**\n   - 스크롤을 내리면 Community 에디션 다운로드 버튼이 보인다. OS에 맞는 파일을 다운로드한다.\n     ![IntelliJ IDEA Community 다운로드](./다운로드.png)\n2. IntelliJ 실행 후, `File > Project Structure > SDKs > JDK` 설정\n   ![JDK설정](./JDK설정.png)\n   - JDK를 별도로 설치 하지 않았다면, Download JDK에서 다운로드 할 수 있다. 경로 연결은 알아서 설정된다.\n   - 이미 설치되어 있다면, `Add JDK from disk`를 선택하고 Java Home path 경로를 설정해준다.\n\n---\n\n## Java 코드 작성하기\n\n### 1. 프로젝트 생성\n\n- New Project → Java 선택 → JDK 선택 후, `Create`\n  ![New Project](./new-project.png)\n\n  ![Project](./프로젝트.png)\n  - 다음과 같이 프로젝트가 생성되고, **기본 프로젝트 루트 경로인 `src`** 안에 **Main 클래스**가 생성된다. 이제 자바 코드를 작성 할 수 있다.\n\n### 2. 패키지 생성\n\n- 프로젝트 내부에서 패키지를 생성하고자 하는 경로 우클릭 → New → Package\n  - 기본 프로젝트 루트 경로인 `src` 안에 생성해야한다.\n    ![New Package](./new-package.png)\n- `com.example.app`와 같이 패키지 명 설정\n\n#### 패키지란?\n\n> Java 클래스들을 묶는 이름공간(namespace)으로,\n> 실제로는 폴더 구조와 1:1 대응된다.\n>\n> 같은 이름의 클래스라도 패키지가 다르면 구분 가능하다.\n\n### 3. 클래스 생성\n\n- 프로젝트 내부에서 클래스를 생성하고자 하는 경로 우클릭 → New → Java Class\n  - 기본 프로젝트 루트 경로인 `src` 안에 생성해도 된다.\n    ![New Class](./new-class.png)\n- 코드 작성\n\n  ```java\n  package com.example.app;\n\n  public class Main {\n      public static void main(String[] args) {\n          System.out.println(\"Hello world!\");\n      }\n  }\n  ```\n\n  - 실행 ▶️ 버튼을 클릭하면 `main`메소드가 실행횐다.\n\n---\n\n## JAR 파일 만들고 실행하기\n\n### JAR(Java ARchive)이란?\n\n> Java 클래스 파일(.class), 리소스 파일(.xml, .properties, 이미지 등)을 하나로 묶은 압축 파일\n\n- 여러 개의 .class와 리소스를 한 번에 배포하기 편하게 묶음\n\n- 라이브러리(JAR 파일)를 다른 프로젝트에서 import해서 재사용\n\n- Main Class가 지정된 경우, 실행 가능한 프로그램으로 사용\n\n### IntelliJ Artifacts로 JAR 만들기\n\n1. **File → Project Structure → Artifacts**\n   ![Artifacts](./jar-artifacts.png)\n   - **`+` → JAR → Empty**\n     - Main Class가 없는 경우(main 메소드 실행 코드가 없을 경우) 선택한다.\n     - Output Layout 탭에서 어떤 .class와 리소스를 넣을지 설정해야한다.\n   - **`+` → JAR → From modules with dependencies…**\n     - **Main Class**에 Main Class 지정\n       ![Main Class 지정](./jar-module.png)\n       - main 메소드가 있는 클래스를 지정해준다. jar 실행 시, 이 클래스의 main 메소드가 실행된다.\n         ![설정보기](./자세한설정.png)\n         - Output Directory 설정한 경로에 jar 파일이 생성 될 것이다.\n\n2. **Build → Build Artifacts… → Build**\n3. `out/artifacts/.../앱이름.jar` 확인\n   ![jar 생성 확인](./jar확인.png)\n\n이렇게 생성된 jar 파일을 아래와 같이 실행해 볼 수 있다.\n\n```bash\njava -jar 앱이름.jar\n```\n\n위의 [Java 코드 작성하기 - 3. 클래스 생성]에서 작성한 `Hello world!`를 출력하는 코드를 jar을 생성하여 실행해보았다.\n![helloWorld](./helloWorld.png)\nmain 메소드에 작성한 내용이 실행되어 Hello world!가 잘 출력되고있다.\n","frontmatter":{"date":"2025년 9월 9일","slug":"til-20250909","title":"IntelliJ(Community)로 Java 코드 작성하기","category":"til-challenge","tags":["bootcamp","multi-campus","ureca-backend","java"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACXklEQVR42p2TXWhSYRjHj26YR7JdzRWB0k1eyG6sMColq0mu2sdpk5yi1RhZa7WNInVS5hGqkQl9EVIrylaOjQWzghEEQSiJotBNF1FXXuVNF9MI/Hf2Ts88w0K6+PO+z/k/7+88z/tBvTUEsGi6jdF2ByiKgogSkbEhiVZyN3c9whbPEhQXf4CaN17HK/MDnNUOEdN80IzJG5NgAyzUajW/WKfTwel01gBFFVFo7XmKjb7fWO/+CWr6QAgvD0/Btd1FzEOdnSguFZFOp6FSqXiA1+tFLpfjY9FydZUKW5jn2HAFkHqLoKZMd/C4OwrntjN8ciKRQCAQIHOZTEZGt9uNTCZTFyjti0EWAOgJDniPa/c+M4OBHSN8ciqVQjAYJHOapnlgNputC5T0z0LGcsDlCkNcu6H+efTtHCdmc1MzaS0cDpOYYRhoNBpEIhEkk0nhgVSBllnQVWCw+xmC1jdg9B5ijo2OoVwuI5/PQ6vVgmVZlEolFAoFWK1WkiMWiwWnLAD6mBgm7O9g3r0ClMvlaGtrg0KhgEQiId+USiWJ/3ZtBMALXLvjjg/Yv8e3ujc1i2rjtV5d4PCxOE6fTEJv8FfaaSItrdW/LrYAOGhbxPGhDHR72fpVNPBSBMABx3tYXJ+h3XeNmHq9AXa7HRaLhchms8FoNDYO7D3xEV3DX9DecZOYl9wexOOvEYvNEC0sxOH3XxVelaoqWyGxzK0CzYOf0HHuG7aabgn++t8tG0/lsGvkKzRcpZvMd9F65CFaep6AZqJYd/QFLwkzXV+9UUjPfwd9ucw9vV/4A5K5/u0UD6FzAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/623154fc417e74be99de4e14ebfba4a1/28c56/til-20250909.png","srcSet":"/static/623154fc417e74be99de4e14ebfba4a1/840e3/til-20250909.png 150w,\n/static/623154fc417e74be99de4e14ebfba4a1/0fb21/til-20250909.png 300w,\n/static/623154fc417e74be99de4e14ebfba4a1/28c56/til-20250909.png 600w","sizes":"(min-width: 600px) 600px, 100vw"},"sources":[{"srcSet":"/static/623154fc417e74be99de4e14ebfba4a1/6aa7a/til-20250909.webp 150w,\n/static/623154fc417e74be99de4e14ebfba4a1/bc227/til-20250909.webp 300w,\n/static/623154fc417e74be99de4e14ebfba4a1/6128c/til-20250909.webp 600w","type":"image/webp","sizes":"(min-width: 600px) 600px, 100vw"}]},"width":800,"height":600}}}}},{"id":"2f2d7e84-2eb3-5903-bd29-952f2529c388","excerpt":"블로그를 배포하고, 글을 몇 개 작성했다. 그리고 페이지 별 title 메타 태그 같은것도 설정해주었다. 하지만 아이디를 검색해보면, 내 블로그가 나오지 않고 전혀 다른 컨텐츠들이 노출된다. (여기 검색 된 인스타와 유튜브 계정은 다른 사람의 계정인…","body":"\n![aaxx98을 검색했을 때...](./search-aaxx98.png)\n\n블로그를 배포하고, 글을 몇 개 작성했다. 그리고 페이지 별 title 메타 태그 같은것도 설정해주었다.\n\n하지만 아이디를 검색해보면, 내 블로그가 나오지 않고 전혀 다른 컨텐츠들이 노출된다. (여기 검색 된 인스타와 유튜브 계정은 다른 사람의 계정인 것 같다.)\n\n검색 결과에 내 블로그를 노출시키려면 검색엔진에 요청해야한다.\n\n나의 Gatsby 블로그가 검색 엔진에 검색 될 수 있도록 여러가지 설정을 해 주었다.\n\nGoogle Search Console과 플러그인으로 간단하게 설정 할 수 있다.\n\n# 검색 노출을 위한 Google Search Console 연동\n\n## [Google Search Console](https://search.google.com/search-console)\n\n![search-console-attr](./search-console-attr.png)\n\n- Google Search Console에 접속하여 URL 접두어에 블로그 url을 입력한다.\n- 이제 입력한 url의 웹페이지에 대한 소유권 확인이 필요하다. 소유권 확인 창에서, 다른 확인 방법 > HTML 태그를 열어서 코드를 복사한다.\n  - google-site-verification 메타 태그를 받아서 `<head>` 태그 내부에 삽입해주면, Google 크롤러가 해당 태그를 읽어 사이트 소유권을 확인해준다.\n  - `<head>` 요소를 `Seo 컴포넌트`에서 관리하고 있어서 내부에 메타 태그를 추가해주었다.\n  - 적용한 후에 `<head>`내부에서 메타 태그를 찾아보자.\n    ![google-site-verification 메타 태그 확인](./site-verification.png)\n  - 등록한 url 페이지에 배포해야한다. 변경사항을 배포하고, 배포가 완료 되었으면 소유권 확인을 완료하자.\n\n## 사이트맵(sitemap) 생성\n\n- 필요 플러그인: `gatsby-plugin-sitemap`\n\n- 설치\n\n  ```console\n  npm install gatsby-plugin-sitemap\n  ```\n\n- `gatsby-config.js` 설정\n  ```TypeScript\n  plugins: [\n    'gatsby-plugin-sitemap',\n  ]\n  ```\n\n설정 후, 빌드하면 `public/sitemap-index.xml`, `public/sitemap-0.xml`이 생성된다.\n\n- `/sitemap-index.xml`로 접근 할 수 있다.\n  ![sitemap-index](./sitemap-index.png)\n\n이 파일을 Google Search Console에 제출하면, 구글이 블로그 전체 페이지 구조를 한 번에 파악할 수 있다.\n\n- Google Search Console > 색인생성 > Sitemaps에서 사이트맵 링크를 추가해주자.\n  ![사이트맵 설정](./search-console-sitemap.png)\n\n## robots.txt 구성\n\n- 필요 플러그인: `gatsby-plugin-robots-txt`\n\n- 설치\n\n  ```console\n  npm install gatsby-plugin-robots-txt\n  ```\n\n- `gatsby-config.js` 설정\n\n  ```TypeScript\n  plugins: [\n    {\n      resolve: \"gatsby-plugin-robots-txt\",\n      options: {\n        policy: [{ userAgent: \"*\", allow: \"/\" }],\n      },\n    }\n  ]\n  ```\n\n`robots.txt`가 있으면 크롤러가 사이트 접근 정책과 사이트맵 위치를 쉽게 알 수 있게 된다.\n\n설정 후, 빌드하면 `public/robots.txt`가 생성된다.\n\n- `/robots.txt`로 접근 할 수 있다.\n  ![robots.txt](./robots-txt.png)\n\n`{ userAgent: \"*\", allow: \"/\" }`에서, userAgent는 검색 엔진 크롤러의 종류이고, allow는 크롤링을 허용할 경로를 의미한다.\n\n모든 크롤러, 모든 경로로 설정한 것이므로, 모든 검색엔진 크롤러는 이 사이트의 모든 경로를 자유롭게 크롤링해도 된다는 뜻이다.\n\n---\n\n# 뭔가 잘 안됨😅\n\n2025/09/03 13시 46분에 Google Search Console을 먼저 연동하고, 15시 쯤 사이트맵 플러그인을 적용하여 사이트맵 설정을 했습니다.\n\n그런데... 사이트맵을 읽을 수 없음 상태로 아직 색인되지 않고있습니다.\n\n`sitemap-index.xml`이 정상적으로 생성되고 있는데, 최근 크롤링 시간이 14시로 아직 검색엔진에 크롤링이 안된 것 같아서 좀 더 기다려보겠습니다.\n\n![Google Search Console URL 검사 결과](./search-console-url.png)\n","frontmatter":{"date":"2025년 9월 3일","slug":"gatsby-blog-3","title":"Gatsby 블로그 구축하기 (3) - 구글 검색에 블로그 노출하기","category":"blog","tags":["gatsby","seo","blog"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB8klEQVR42pVTS2sTURTO/3XpSly4cuNKQXFRwYUGFESNWotZVAsmEGKl1JQqtGlmMiRxknlmksl9fp47M0nzaLQeOJw75/Gdc+a7t4Ql0UZ1bv8mGttzSuuOlGkwUZQpSUbRmVTLDETRUc07m/gadAaoC99JV+L5V4b9lgAXl9PMRRWJp/45Tr2zPK711RMKavb0gCFMFBoXQPvcB3/3ErNmA8rbBfpP0O5H+NAEHjW/o3b4Gig/A3esorPeXLlc4zixOXYawJuHVeDtC8Q7d8GPbxHgA7z6VMXnFnCzeoT9+zcg7twGO/tZjK82Vx7GGpVvHAe/NNI4AdurgP04hgy+AG4ZLXuCexWFx7UBBp1D8N33kCN3+4RbWS0autTw4xGnxmrFfwUpmibWkDS2kAqSVEkJJURulbGC8tSCJkW5mjSzVD8HL5mPGWNZ4F9iWDZ1lmVjOpkgiiIwqg2CANNpmgMaoDSd0TUR11g9H6Ner8N1XfR6PSRJAsdxEMfxJaCktYwKAjXKC7tNDbDMfoXKfUW98S/+4bIuPy+z5nxVvWYXsSV2Vlg2pDi9PtoXFjp2FxYp4zybuD/4DbvrUKyT5ZjYyPM33vQKoGE6isdwhyP4QZid83UUovEYIZEwHHkIwhCeHyAeTzauzrXu4f/IH2v5h/zHg2NsAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/f8571b45d7b598fbe3fef991b50a9b26/4c3f5/google.png","srcSet":"/static/f8571b45d7b598fbe3fef991b50a9b26/67385/google.png 127w,\n/static/f8571b45d7b598fbe3fef991b50a9b26/600bb/google.png 254w,\n/static/f8571b45d7b598fbe3fef991b50a9b26/4c3f5/google.png 507w","sizes":"(min-width: 507px) 507px, 100vw"},"sources":[{"srcSet":"/static/f8571b45d7b598fbe3fef991b50a9b26/f117c/google.webp 127w,\n/static/f8571b45d7b598fbe3fef991b50a9b26/7b72e/google.webp 254w,\n/static/f8571b45d7b598fbe3fef991b50a9b26/2284a/google.webp 507w","type":"image/webp","sizes":"(min-width: 507px) 507px, 100vw"}]},"width":800,"height":599.6055226824458}}}}},{"id":"ac725582-b5c4-5079-a939-e3defa8dc1aa","excerpt":"Utterances는 GitHub Issues 기반의 댓글 위젯으로, 별도의 서버를 구축할 필요 없이 깔끔하게 댓글 시스템을 붙일 수 있다. 댓글이 달리면 지정한 GitHub 저장소의 Issues에 등록되고, Issues에서 댓글을 관리할 수 있다.…","body":"\n# Utterances 소개\n\nUtterances는 GitHub Issues 기반의 댓글 위젯으로, 별도의 서버를 구축할 필요 없이 깔끔하게 댓글 시스템을 붙일 수 있다.\n댓글이 달리면 지정한 GitHub 저장소의 Issues에 등록되고, Issues에서 댓글을 관리할 수 있다.\n\nGithub 계정으로 로그인하고 댓글을 작성하면 아래와 같이 Issue에 등록된다.\n\n![github issue](./utterances-capture.png)\n\n## 설정 방법\n\n아래와 같은 형식인데 utterances 사이트에서 설정 값을 선택하면 스크립트를 생성해준다.\n\n[Utterances 공식 사이트](https://utteranc.es/) - configuration 항목에서 옵션을 선택한다.\n\n- Repository: username/repo명, 공개 레포지토리만 사용 가능하다. 블로그 레포가 비공개인 경우 댓글 Issue를 등록할 공개 레포지토리를 만들어서 사용하면 된다.\n\n- Blog Post ↔️ Issue Mapping: 포스트별로 구분할 기준, pathname을 선택했다.\n\n- Theme: 디자인 테마 선택\n\n- Repository에 권한 설정 - [utterances app](https://github.com/apps/utterances)에서 Issue 등록을 위해 utterances에서 사용할 레파지토리 권한을 설정해준다.\n\n일반 HTML 파일이나 정적 페이지에서는 Enable Utterances에 생성된 스크립트를 복사하여 붙여넣으면 되지만, Gatsby에서 사용하기 위해서는 React 컴포넌트 형식으로 변환해주어야한다.\n\n![enable utterances](./enable-utterances.png)\n\n## React 컴포넌트로 변환\n\nGatsby는 SSR을 수행하므로 빌드 시점에 DOM이 없어 `<script`>가 실행되지 않는다.\n\nReact는 가상 DOM을 관리하므로 외부 스크립트가 직접 DOM을 건드리면 충돌이 발생한다.\n\nuseEffect를 사용해 브라우저 환경에서만 스크립트를 삽입해 정상적으로 동작하게 해야한다.\n\n- Comment 컴포넌트 생성\n\n  ```TypeScript\n  import React, { useEffect, useRef, useState } from \"react\";\n\n  const Comment = () => {\n  const commentsEl = useRef<HTMLDivElement | null>(null);\n  const [status, setStatus] = useState<\"pending\" | \"success\" | \"failed\">(\n      \"pending\"\n  );\n\n  useEffect(() => {\n      const existingScript = commentsEl.current?.querySelector(\"script\");\n      if (existingScript) {\n      existingScript.remove();\n      }\n\n      const scriptEl = document.createElement(\"script\");\n      scriptEl.onload = () => setStatus(\"success\");\n      scriptEl.onerror = () => setStatus(\"failed\");\n      scriptEl.async = true;\n      scriptEl.src = \"https://utteranc.es/client.js\";\n      scriptEl.setAttribute(\"repo\", \"aaxx98/aaxx98.github.io\");\n      scriptEl.setAttribute(\"issue-term\", \"pathname\");\n      scriptEl.setAttribute(\"theme\", \"github-light\");\n      scriptEl.setAttribute(\"crossorigin\", \"anonymous\");\n\n      if (commentsEl.current) {\n      commentsEl.current.appendChild(scriptEl);\n      }\n\n      // cleanup function\n      return () => {\n      if (commentsEl.current) {\n          const script = commentsEl.current.querySelector(\"script\");\n          if (script) {\n          script.remove();\n          }\n      }\n      };\n  }, []);\n\n  return (\n      <div className=\"w-full max-w-[850px] mx-auto px-8 mt-8\">\n      {status === \"failed\" && (\n          <div className=\"text-red-500 text-center p-4\">\n          댓글을 불러오는 중 오류가 발생했습니다. 새로고침 후 다시 시도해주세요.\n          </div>\n      )}\n      {status === \"pending\" && (\n          <div className=\"text-gray-500 text-center p-4\">\n          댓글을 불러오는 중...\n          </div>\n      )}\n      <div\n          ref={commentsEl}\n          className=\"utterances-container\"\n          style={{\n          minHeight: \"200px\",\n          width: \"100%\",\n          display: \"block\",\n          }}\n      />\n      </div>\n  );\n  };\n\n  export default Comment;\n  ```\n\n위에서 생성한 Comment를 원하는 위치에서 사용하면 된다.\n\n처음 작성하고 댓글이 표시되지 않았었는데, repo 경로에 오타가 있었다.\n\n잘 나타나지 않는 경우 repo를 제대로 지정했는지, 권한 설정을 했는지 확인해보자.\n","frontmatter":{"date":"2025년 9월 1일","slug":"gatsby-blog-2","title":"Gatsby 블로그 구축하기 (2) - Utterances 연동해서 댓글란 만들기","category":"blog","tags":["gatsby","utterances","github","blog"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAAC1ElEQVR42pVT7UtTURzel772tT+igqCvQmFJfQjUEiRjflhG5kstrMSQZpjORAsRk0oiKXUVkpSaWVlUlC8V6mwvba65e3d397673W13b/fp3EMTgwz7we8+95zz4zm/l+eocrkcFIvFw7DajGDcdmRzGcg5GdlslpzIkGVs2VQsy6K2phonyi6geP9VlOxrgra6ES7WQQNkwhYMhjC/8AWfZ+ewtLyC7yYzQSNMZgtsNjtZE7Sv0ljVyUo1agvq0XbaiZ5zUXTpRGg071BRWotoLExJZ+fmMTT8CJNT07h99x7GJ15gZOQxJianMPp0DA+HDRh7Nk4rUqnL69GsnsXNBh86NA5cHvChfQaoKBjAg6FBSphOZ6C0Rskg7/nsFZL8GS259FAztOULaD/D43odi446Bjca/NCWfYK+rZsGJZMSEokkdTGeQFKSKCouSal1MkpYXFQE8/QB3NGNQl8TQGedC30Xo6g68hy9vX00yOsLYI1xY9Fohslig23VCfMPO74trcBF9vODpYQa9U4Y32xDf0sPzh9fxpUqCxorTSg+qCWNNtMgKZUi/RQRiUQp0n8hipgYhxCNIRiOkLVAK1AtLltRUrgX/ZcMaKuZxq2mGZwtPYUWXTMlU3oUjghwOF1gWI6i4k4XAw/vI2rgSLar+LpoRDAUhiohpaEuOQxt4Q7oju5Ga9kuHNuzHYOD99cJlUDOw4PlPJRccTfH4+caA18gCI4Q59uoUj52hwPdXd3o1LdDf60VBsMTpFLp38IGBCEG1u0B7/UjRMpTLnCTC1wMR1HJfH3Kmyl+ozxCYYEOhXFzFHNybvOXonyUKWUyGZpR3jdKIU7kwXt98PuD8AdChFDeoEn8KZutvM94OgFfPACv6AdPnI3wiEqxzTP8V9mKcYIXr60f8cryAS/N7zFpegs32ftvwrylMkSHSRFiKg5RItpLxiCRvb8R/gKf0yzDbAZojQAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/a3dbdb53527872506109d74af949b679/ce24c/utterances-thumbnail.png","srcSet":"/static/a3dbdb53527872506109d74af949b679/aacf3/utterances-thumbnail.png 200w,\n/static/a3dbdb53527872506109d74af949b679/0e3a3/utterances-thumbnail.png 400w,\n/static/a3dbdb53527872506109d74af949b679/ce24c/utterances-thumbnail.png 800w,\n/static/a3dbdb53527872506109d74af949b679/ee2e1/utterances-thumbnail.png 1600w","sizes":"(min-width: 800px) 800px, 100vw"},"sources":[{"srcSet":"/static/a3dbdb53527872506109d74af949b679/abf68/utterances-thumbnail.webp 200w,\n/static/a3dbdb53527872506109d74af949b679/ce081/utterances-thumbnail.webp 400w,\n/static/a3dbdb53527872506109d74af949b679/c11e0/utterances-thumbnail.webp 800w,\n/static/a3dbdb53527872506109d74af949b679/0843b/utterances-thumbnail.webp 1600w","type":"image/webp","sizes":"(min-width: 800px) 800px, 100vw"}]},"width":800,"height":600}}}}},{"id":"ef3b8d12-9ab4-5ad2-b3e6-e51e4114cd89","excerpt":"Gatsby 소개와 선택한 이유 Gatsby는 React 기반의 정적 사이트 생성기(Static Site Generator, SSG)다.\n\nNext.js처럼 서버 사이드 렌더링을 지원하는 프레임워크도 있지만, Gatsby는 서버가 없고 정적 파일을…","body":"\n![Gatsby js](./gatsby-blog.png)\n\n# Gatsby 블로그\n\n## Gatsby 소개와 선택한 이유\n\nGatsby는 React 기반의 정적 사이트 생성기(Static Site Generator, SSG)다.\n\nNext.js처럼 서버 사이드 렌더링을 지원하는 프레임워크도 있지만, Gatsby는 서버가 없고 정적 파일을 빌드해서 배포하는 데 특화되어 있다.\n\n정적 사이트 생성기의 특징은 모든 페이지가 HTML, CSS, JS 파일로 미리 렌더링된다는 점이다. 덕분에 GitHub Pages 같은 정적 호스팅 서비스만 있으면 별도 운영비가 들지 않고 빠르게 배포할 수 있다.\n\n## Gatsby init부터 deploy까지\n\nGatsby 공식문서 튜토리얼대로 따라하면 되기 때문에 세팅이 간단했다.\n\nTypeScript를 선호하기 때문에 `gatsby new`로 프로젝트 생성 시에 TypeScript 사용을 선택했다.\n\n블로그 디자인은 간단하게 className으로 조정하며 만드려고 해서 tailwind css를 사용했다.\n\n레포지토리를 생성하고, Github Pages 설정 후, `npm run deploy` 명령어 한 줄만 실행하면, 빌드된 정적 페이지가 자동으로 gh-pages 브랜치에 생성되어 배포되는 것을 확인할 수 있었다.\n\nGithub Actions 스크립트로 자동배포 설정을 해두어 main에 push하면 자동 배포되도록 설정했다.\n\n### 참고\n\n- [Gatsby TypeScript 가이드](https://www.gatsbyjs.com/docs/how-to/custom-configuration/typescript/)\n- [Gatsby getting started](https://www.gatsbyjs.com/docs/tutorial/getting-started/)\n- [Install Tailwind CSS with Gatsby](https://tailwindcss.com/docs/installation/framework-guides/gatsby)\n- [Github Pages로 배포](https://www.gatsbyjs.com/docs/how-to/previews-deploys-hosting/how-gatsby-works-with-github-pages/)\n","frontmatter":{"date":"2025년 8월 21일","slug":"gatsby-blog-1","title":"Gatsby 블로그 구축하기 (1) - Gatsby 프로젝트 생성","category":"blog","tags":["gatsby","react","blog","tailwind-css"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/ElEQVR42mMI0WklGzFQpDlMry1cvz1Mvz1Ur41kzX4qjd4KdUAUoN4cBtev2woyTheLhjAkOxjyfKZPq90yqWJjst0Ef9XGUN02oJ5g7RZvxfpAzWYwF4SAeoAkUEOAelOoTiuEzXBi942Dmy8f2nL54KZL2R5TgXJBWi2RRh0VkfMTbftCtFsDNZqDtVqA5gYBzdJrKw6aDTQaKAJkMxzdce3///+f3n/98PbrntXnvRXroow71805unbW0f7S9UCdWR5Tkmz7ga6Lt+pNdZy4Ye6xHK/pkcadIJu3LD757fOPzx++Hd91/fDWK77KDRUR89fMOAIMgg1zj6+bfXTV9EPr5xzdu/b8ullHF/Xs2bTgBFBk65JTMxu3M0yv27py6sFHt1/tWH5m1bRDQM1xlj07V54F2nxk21WgIFA10IL5HbtmNm47f+TOtiWnti87Awyj0/tuMezfcAlo4YGNl47tvAbxM9CpiTZ9nbmrY8y7w/TbGpKWpDlNSrDuy/acBlQAJMvD52W5T9208AQDkAN0wJTqTbEWPX7Q0G4D6veQrQ3SbAGGjZd8rb8ayESgLBD5qzW6y1QDPZ/hOpkByPECxrNiPTCQ4XEYCk45oPjQbQUlIT1IbIEYoERl0A4M+UCNJgagwyIMOsINOkhKYcC0ADSFYcAyBgAwr3ojnjL9xwAAAABJRU5ErkJggg=="},"images":{"fallback":{"src":"/static/94688911b8f5aaa3a414502512ddaf6f/ce24c/gatsby-blog.png","srcSet":"/static/94688911b8f5aaa3a414502512ddaf6f/aacf3/gatsby-blog.png 200w,\n/static/94688911b8f5aaa3a414502512ddaf6f/0e3a3/gatsby-blog.png 400w,\n/static/94688911b8f5aaa3a414502512ddaf6f/ce24c/gatsby-blog.png 800w","sizes":"(min-width: 800px) 800px, 100vw"},"sources":[{"srcSet":"/static/94688911b8f5aaa3a414502512ddaf6f/abf68/gatsby-blog.webp 200w,\n/static/94688911b8f5aaa3a414502512ddaf6f/ce081/gatsby-blog.webp 400w,\n/static/94688911b8f5aaa3a414502512ddaf6f/c11e0/gatsby-blog.webp 800w","type":"image/webp","sizes":"(min-width: 800px) 800px, 100vw"}]},"width":800,"height":600}}}}}]}}}